autoloader
 [x] Can load s9e\TextFormatter\Configurator
 [x] Can load s9e\TextFormatter\Parser\Tag
 [x] Can load s9e\TextFormatter\Plugins\Emoticons\Parser

s9e\TextFormatter\Tests\Configurator\Collections\Collection
 [x] Collection is countable
 [x] Collection is iterable with foreach
 [x] clear() empties the collection
 [x] asConfig() returns the items as an array

s9e\TextFormatter\Tests\Configurator\Collections\NormalizedCollection
 [x] set() calls normalizeKey()
 [x] set() calls normalizeValue()
 [x] add() calls normalizeKey()
 [x] add() calls normalizeValue()
 [x] add() can be called without a second parameter
 [x] get() throws a RuntimeException if the item already exists
 [x] exists() returns TRUE if the item exists
 [x] exists() returns FALSE if the item does not exist
 [x] exists() calls normalizeKey()
 [x] get() returns an item by name
 [x] get() calls normalizeKey()
 [x] get() throws a RuntimeException if the item does not exist
 [x] delete() removes an item by name
 [x] delete() calls the item's normalizeKey() method
 [x] isset($collection['foo']) maps to $collection->exists('foo')
 [x] $collection['foo'] maps to $collection->get('foo')
 [x] $collection['foo'] = 42 maps to $collection->set('foo', 42)
 [x] unset($collection['foo']) maps to $collection->delete('foo')
 [x] contains() returns true if the given value is present in the collection
 [x] contains() returns false if the given value is not present in the collection
 [x] contains() checks for equality, not identity
 [x] indexOf() returns the key if the given value is present in the collection
 [x] indexOf() returns false if the given value is not present in the collection
 [x] indexOf() checks for equality, not identity

s9e\TextFormatter\Tests\Configurator\Collections\NormalizedList
 [x] append() adds the value at the end of the list
 [x] $normalizedList[] = 'foo' maps to $normalizedList->append('foo')
 [x] prepend() adds the value at the beginning of the list
 [x] insert() inserts the value at given offset
 [x] insert() can insert value that is an array
 [x] insert() throws an exception if the offset is out of bounds
 [x] $normalizedList[0] = 'foo' replaces the first value of the list if it exists
 [x] $normalizedList[0] = 'foo' appends to the list if it's empty
 [x] $normalizedList[1] = 'foo' throws an InvalidArgumentException if the list is empty
 [x] $normalizedList['foo'] = 'bar' throws an InvalidArgumentException
 [x] Deleting a value by key reorders the list to remove gaps

s9e\TextFormatter\Tests\Configurator\Traits\CollectionProxy
 [x] $proxy->add() gets forwarded to $proxy->collection->add() with all arguments
 [x] $proxy->add() returns the value returned by $proxy->collection->add()
 [x] $proxy->exists() gets forwarded to $proxy->collection->exists() with all arguments
 [x] $proxy->delete() gets forwarded to $proxy->collection->delete() with all arguments
 [x] $proxy->get() gets forwarded to $proxy->collection->get() with all arguments
 [x] $proxy->get() returns the value returned by $proxy->collection->get()
 [x] $proxy->set() gets forwarded to $proxy->collection->set() with all arguments
 [x] $proxy->set() returns the value returned by $proxy->collection->set()
 [x] $proxy['foo'] returns $proxy->collection['foo']
 [x] $proxy['foo'] = 42 sets $proxy->collection['foo'] = 42
 [x] isset($proxy['foo']) returns isset($proxy->collection['foo'])
 [x] unset($proxy['foo']) calls unset($proxy->collection['foo'])
 [x] count($proxy) returns count($proxy->collection)
 [x] A collection proxy is iterable with foreach

s9e\TextFormatter\Tests\Configurator\Traits\Configurable
 [x] __get('foo') calls getFoo() if it exists
 [x] __get($k) returns the property if it exists
 [x] __get() throws a RuntimeException if the property does not exist
 [x] __get($k) returns null if the property is null
 [x] __set('foo', 'bar') calls setFoo('bar') if it exists
 [x] __set() can create new properties
 [x] __set() can replace an instance of Foo with another instance of Foo
 [x] __set() can replace an instance of Foo with an instance of FooPlus, which extends Foo
 [x] __set() throws an exception if an instance of Foo would be replaced by an instance of Bar
 [x] __set() can replace a scalar value with a value of the same type
 [x] __set() can replace a scalar value with another scalar value if it can be losslessly cast to the same type
 [x] __set() throws an exception if a scalar value would be overwritten by a scalar value that cannot be losslessly cast to the same type
 [x] __set() will clear and repopulate a NormalizedCollection rather than overwrite it
 [x] __set() throws an exception if a NormalizedCollection would be overwritten by a non-array, non-Traversable value
 [x] __isset($k) returns true if the property exists

s9e\TextFormatter\Tests\Configurator
 [x] $configurator->customFilters is an instance of FilterCollection
 [x] $configurator->plugins is an instance of PluginCollection
 [x] $configurator->rootRules is an instance of Ruleset
 [x] $configurator->stylesheet is an instance of Stylesheet
 [x] $configurator->tags is an instance of TagCollection
 [x] $configurator->urlConfig is an instance of UrlConfig
 [x] asConfig() returns an array with a rootContext element
 [x] asConfig() returns an array with a registeredVars element that contains urlConfig
 [x] asConfig() adds regexpLimit to the plugin's configuration if it's not specified and the plugin has a regexp
 [x] asConfig() removes regexpLimit from the plugin's configuration if it does not have a regexp
 [x] asConfig() adds regexpLimitAction to the plugin's configuration if it's not specified and the plugin has a regexp
 [x] asConfig() removes regexpLimitAction from the plugin's configuration if it does not have a regexp
 [x] asConfig() adds quickMatch to the plugin's configuration if available
 [x] asConfig() omits a plugin's quickMatch if it's false
 [x] allowedChildren and allowedDescendants bitfields are added to each tag
 [x] getParser() returns an instance of s9e\TextFormatter\Parser
 [x] getRenderer() returns an instance of s9e\TextFormatter\Renderer
 [x] $configurator->BBCodes returns $configurator->plugins->load('BBCodes') if the plugin hasn't been loaded already
 [x] $configurator->BBCodes returns $configurator->plugins->get('BBCodes') if the plugin has already been loaded
 [x] $configurator->foo throws an exception
 [x] addHTML5Rules() add root rules
 [x] addHTML5Rules() add tag rules
 [x] addHTML5Rules() passes its options to the generator

s9e\TextFormatter\Tests\Configurator\Collections\AttributeCollection
 [x] add() returns an instance of s9e\TextFormatter\Configurator\Items\Attribute
 [x] add() normalizes the attribute name
 [x] delete() normalizes the attribute name
 [x] exists() normalizes the attribute name
 [x] get() normalizes the attribute name
 [x] set() normalizes the attribute name

s9e\TextFormatter\Tests\Configurator\Lists\AttributeList
 [x] Attribute names are normalized for storage
 [x] Attribute names are normalized during retrieval
 [x] asConfig() returns a deduplicated list of attribute names

s9e\TextFormatter\Tests\Configurator\Collections\AttributePreprocessorCollection
 [x] add() returns an instance of s9e\TextFormatter\Configurator\Items\AttributePreprocessor
 [x] asConfig() returns a list of regexps for each attribute
 [x] Is iterable with foreach
 [x] Uses the name of the source attribute as key when iterating
 [x] merge() accepts a 2D array of regexps
 [x] merge() accepts a 2D array of AttributePreprocessor instances
 [x] merge() accepts an instance of AttributePreprocessorCollection to copy its content
 [x] merge() throws an exception when passed a non-array, non-AttributProcessorCollection
 [x] merge() throws an exception when passed a one-dimensional array

s9e\TextFormatter\Tests\Configurator\Collections\FilterChain
 [x] append() adds the filter at the end of the chain
 [x] prepend() adds the filter at the beginning of the chain
 [x] append() correctly records filter vars
 [x] prepend() correctly records filter vars
 [x] append() throws an InvalidArgumentException on invalid callbacks
 [x] prepend() throws an InvalidArgumentException on invalid callbacks
 [x] append() throws an InvalidArgumentException on uncallable callbacks
 [x] prepend() throws an InvalidArgumentException on uncallable callbacks
 [x] $filterChain[] = 'foo' maps to $filterChain->append('foo')
 [x] PHP string callbacks are normalized to an instance of ProgrammableCallback
 [x] PHP array callbacks are normalized to an instance of ProgrammableCallback
 [x] Instances of CallbackPlaceholder are normalized to an instance of ProgrammableCallback
 [x] Instances of ProgrammableCallback are added as-is
 [x] Generated instances of ProgrammableCallback based on PHP callbacks adopt the default signature
 [x] contains() returns false if the given filter is not present in the chain
 [x] contains() returns true if the given built-in filter is present in the chain
 [x] contains() returns true if the given PHP string callback is present in the chain
 [x] $filterChain['foo'] = 'strtolower' throws an InvalidArgumentException
 [x] Deleting a filter reorders the chain to remove gaps

s9e\TextFormatter\Tests\Configurator\Collections\FilterCollection
 [x] Throws an exception if the value is not an instance of ProgrammableCallback
 [x] Accepts instances of Filter

s9e\TextFormatter\Tests\Configurator\Collections\PluginCollection
 [x] load() can load a stock plugin
 [x] load() throws an exception if the stock plugin does not exist
 [x] Accepts an object that implements ConfiguratorBase
 [x] Accepts a string that is the name of a class that implements ConfiguratorBase
 [x] Throws an exception if the value is neither an instance of or the name of a class that implements ConfiguratorBase
 [x] Throws an exception if the plugin name is not entirely composed of letters, numbers and underscores
 [x] Throws an exception if the plugin name does not start with an uppercase letter

s9e\TextFormatter\Tests\Configurator\Collections\Ruleset
 [x] isset($ruleset['allowChild']) tests whether any allowChild rules exist
 [x] $ruleset['allowChild'] returns the allowChild rules if they exist
 [x] Trying to set rules via array access throws a RuntimeException
 [x] unset($ruleset['allowChild']) clears all allowChild rules
 [x] clear() removes all rules
 [x] clear('allowChild') removes only 'allowChild' rules
 [x] allowChild() throws an exception on invalid tag name
 [x] allowChild() normalizes tag name
 [x] allowDescendant() throws an exception on invalid tag name
 [x] allowDescendant() normalizes tag name
 [x] autoClose() accepts a boolean
 [x] autoClose() throws an exception if its argument is not a boolean
 [x] autoReopen() accepts a boolean
 [x] autoReopen() throws an exception if its argument is not a boolean
 [x] closeAncestor() throws an exception on invalid tag name
 [x] closeAncestor() normalizes tag name
 [x] closeParent() normalizes tag name
 [x] defaultChildRule() accepts 'allow'
 [x] defaultChildRule() accepts 'deny'
 [x] defaultChildRule() throws an exception if passed anything else than 'allow' or 'deny'
 [x] defaultDescendantRule() accepts 'allow'
 [x] defaultDescendantRule() accepts 'deny'
 [x] defaultDescendantRule() throws an exception if passed anything else than 'allow' or 'deny'
 [x] denyAll() accepts a boolean
 [x] denyAll() throws an exception if its argument is not a boolean
 [x] denyChild() throws an exception on invalid tag name
 [x] denyChild() normalizes tag name
 [x] denyDescendant() throws an exception on invalid tag name
 [x] denyDescendant() normalizes tag name
 [x] ignoreText() accepts a boolean
 [x] ignoreText() throws an exception if its argument is not a boolean
 [x] isTransparent() accepts a boolean
 [x] isTransparent() throws an exception if its argument is not a boolean
 [x] noBrChild() accepts a boolean
 [x] noBrChild() throws an exception if its argument is not a boolean
 [x] noBrDescendant() accepts a boolean
 [x] noBrDescendant() throws an exception if its argument is not a boolean
 [x] trimWhitespace() accepts a boolean
 [x] trimWhitespace() throws an exception if its argument is not a boolean
 [x] requireParent() throws an exception on invalid tag name
 [x] requireParent() normalizes tag name
 [x] requireAncestor() throws an exception on invalid tag name
 [x] requireAncestor() normalizes tag name
 [x] merge() accepts a 2D array of rules
 [x] merge() correctly copies the defaultChildRule setting from an array
 [x] merge() correctly copies the defaultDescendantRule setting from an array
 [x] merge() correctly copies the isTransparent setting from an array
 [x] merge() accepts an instance of Ruleset to copy its content
 [x] merge() correctly copies the defaultChildRule setting from an instance of Ruleset
 [x] merge() correctly copies the defaultDescendantRule setting from an instance of Ruleset
 [x] merge() correctly copies the isTransparent setting from an instance of Ruleset
 [x] merge() throws an InvalidArgumentException if its argument is not an array or an instance of Ruleset
 [x] asConfig() does not return rules that are not used during parsing
 [x] asConfig() flips arrays to use target names as keys
 [x] asConfig() packs boolean rules in a value named "flags"
 [x] asConfig() can pack multiple boolean rules in a value named "flags"
 [x] asConfig() sets noBrChild's bit if noBrDescendant is set

s9e\TextFormatter\Tests\Configurator\Collections\TagCollection
 [x] add() returns an instance of s9e\TextFormatter\Configurator\Items\Tag
 [x] add() normalizes the tag name
 [x] delete() normalizes the tag name
 [x] exists() normalizes the tag name
 [x] get() normalizes the tag name
 [x] set() normalizes the tag name

s9e\TextFormatter\Tests\Configurator\Collections\TemplateCollection
 [x] set() accepts a string and returns an instance of Template
 [x] set() accepts a callback and returns an instance of Template
 [x] set() accepts an instance of Template, which it returns
 [x] set() optimizes string templates
 [x] set() checks string templates for unsafe content

s9e\TextFormatter\Tests\Configurator\UnsafeTemplateException
 [x] getNode() returns the stored node

s9e\TextFormatter\Tests\Configurator\Helpers\ConfigHelper
 [x] generateQuickMatchFromList() returns the longest common substring of a list of strings
 [x] generateQuickMatchFromList() returns a string even if it contains only digit characters
 [x] generateQuickMatchFromList() returns FALSE if no common substring is found
 [x] generateQuickMatchFromList() compares strings as bytes and returns a binary string
 [x] toArray() works with deep arrays
 [x] toArray() calls asConfig() for objects in deep arrays that implement ConfigProvider
 [x] toArray() throws an exception for objects in deep arrays that are not Traversable and do not implement ConfigProvider
 [x] toArray() omits NULL values
 [x] toArray() omits empty arrays from values
 [x] toArray() keeps empty arrays if its second argument is TRUE
 [x] replaceBuiltInFilters() replaces built-in attribute filter #int by its callback s9e\TextFormatter\Parser\BuiltInFilters::filterInt
 [x] replaceBuiltInFilters() copies the built-in filters' signatures based on the names of their parameters
 [x] replaceBuiltInFilters() replaces built-in tag filter #filterAttributes by its callback s9e\TextFormatter\Parser::filterAttributes
 [x] replaceBuiltInFilters() replaces custom attribute filter #foo by its registered callback
 [x] replaceBuiltInFilters() replaces custom tag filter #foo by its registered callback
 [x] replaceBuiltInFilters() adds variables set for an attribute filter to the custom filter without overwriting the variables set for the custom filter
 [x] replaceBuiltInFilters() doesn't choke on an empty filterChain
 [x] replaceBuiltInFilters() doesn't touch normal callbacks expressed as a string
 [x] replaceBuiltInFilters() throws an exception on unknown custom filters
 [x] optimizeArray() uses references to deduplicate equal arrays

s9e\TextFormatter\Tests\Configurator\Helpers\HTML5\TemplateForensics
 [x] <span> does not allow <div> as child
 [x] <span> does not allow <div> as child even with a <span> sibling
 [x] <span> and <div> does not allow <span> and <div> as child
 [x] <li> closes parent <li>
 [x] <div> closes parent <p>
 [x] <p> closes parent <p>
 [x] <div> does not close parent <div>
 [x] <span> does not close parent <span>
 [x] <a> denies <a> as descendant
 [x] <a> allows <img> with no usemap attribute as child
 [x] <a> denies <img usemap="#foo"> as child
 [x] <div><a> allows <div> as child
 [x] <span><a> denies <div> as child
 [x] <audio> with no src attribute allows <source> as child
 [x] <audio src="..."> denies <source> as child
 [x] <a> is considered transparent
 [x] <a><span> is not considered transparent
 [x] <span><a> is not considered transparent
 [x] A template composed entirely of a single <xsl:apply-templates/> is considered transparent
 [x] <span> allows <unknownElement> as child
 [x] <unknownElement> allows <span> as child
 [x] <textarea> disallows text nodes
 [x] <table> disallows text nodes
 [x] <table><tr><td> allows "Hi"
 [x] <div><table> disallows "Hi"
 [x] <table> disallows <xsl:value-of/>
 [x] <table> disallows <xsl:text>Hi</xsl:text>
 [x] <table> allows <xsl:text>  </xsl:text>
 [x] <b> should be reopened automatically
 [x] <b><u> should be reopened automatically
 [x] <div> should not be reopened automatically
 [x] "Hi" should not be reopened automatically
 [x] A template composed entirely of a single <xsl:apply-templates/> should not be reopened automatically
 [x] <img> denies all descendants
 [x] <hr><xsl:apply-templates/></hr> denies all descendants
 [x] <div><hr><xsl:apply-templates/></hr></div> denies all descendants
 [x] <style> denies all descendants even if it has an <xsl:apply-templates/> child
 [x] <span> does not deny all descendants if it has an <xsl:apply-templates/> child
 [x] <span> denies all descendants if it does not have an <xsl:apply-templates/> child
 [x] <colgroup span="2"> denies all descendants
 [x] <colgroup> denies all descendants
 [x] <pre> preserves whitespace
 [x] <pre><code> preserves whitespace
 [x] <span> does not preserve whitespace
 [x] <img/> is void
 [x] <img> is void even with a <xsl:apply-templates/> child
 [x] <span> is not void
 [x] <blockquote> is a block-level element
 [x] <span> is not a block-level element

s9e\TextFormatter\Tests\Configurator\Helpers\RulesGenerator
 [x] <div> has an allowChild rule for <div> and <span>
 [x] <span> has a denyChild rule for <div>
 [x] <a> has a denyDescendant rule for <a>
 [x] <a> has a denyChild rule for <a>
 [x] Generates an autoClose rule for <hr/>
 [x] Does not generate an autoClose rule for <span>
 [x] Generates an autoReopen rule for <b>
 [x] Does notg enerates an autoReopen rule for <div>
 [x] Generates an denyAll rule for <hr>
 [x] Generates an denyAll rule for <style>
 [x] Generates an ignoreText rule for <ul>
 [x] Does not generate an ignoreText rule for <b>
 [x] Generates an isTransparent rule for <a>
 [x] Does not generate an isTransparent rule for <b>
 [x] Does not generate a noBrChild rule for <a>
 [x] Does not generate a noBrDescendant rule for <ol>
 [x] Generates a noBrDescendant rule for <pre>
 [x] Generates a noBrDescendant rule for <style>
 [x] Root has an allowChild rule for <span>
 [x] Root has a denyChild rule for <li> if parentHTML is not specified
 [x] Root has an allowChild rule for <li> if parentHTML is <ul>
 [x] <span> has a denyChild rule for <a> if parentHTML is <a>
 [x] Generates a trimWhitespace rule for <div>
 [x] Does not generate a trimWhitespace rule for <span>
 [x] Uses the renderer to generate a template

s9e\TextFormatter\Tests\Configurator\Helpers\RegexpBuilder
 [x] fromList(['foo']) returns 'foo'
 [x] fromList(['foo', 'foo']) returns 'foo'
 [x] fromList(['a']) returns 'a'
 [x] fromList(['a', 'a']) returns 'a'
 [x] fromList(['/']) returns '\\/'
 [x] fromList(['/'], ["delimiter" => "#"]) returns '/'
 [x] fromList(['#'], ["delimiter" => "#"]) returns '\\#'
 [x] fromList(['apple', 'april']) returns 'ap(?:ple|ril)'
 [x] fromList(['bar', 'baz']) returns 'ba[rz]'
 [x] fromList(['foo', 'fool']) returns 'fool?'
 [x] fromList(['ax', 'axed']) returns 'ax(?:ed)?'
 [x] fromList(['!', '#', '$', '(', ')', '*', '+', '-', '.', ':', '<', '=', '>', '?', '[', '\\', ']', '^', '{', '|', '}']) returns '[-!#$()*+.:<=>?[\\\\\\]{|}^]'
 [x] fromList(['xy', '^y'], ["specialChars" => ["^" => "^"]]) returns '(?:x|^)y'
 [x] fromList(['xy', 'x$'], ["specialChars" => ["$" => "$"]]) returns 'x(?:y|$)'
 [x] fromList(['foo', 'bar']) returns '(?:bar|foo)'
 [x] fromList(['*foo', '\\bar'], ["useLookahead" => true]) returns '(?=[*\\\\])(?:\\*foo|\\\\bar)'
 [x] fromList(['?', 'bar'], ["specialChars" => ["?" => "."], "useLookahead" => true]) returns '(?:.|bar)'
 [x] fromList(['a', 'b']) returns '[ab]'
 [x] fromList(['♠', '♣', '♥', '♦']) returns '[♠♣♥♦]'
 [x] fromList(['♠', '♣', '♥', '♦', '.'], ["specialChars" => ["." => "."]]) returns '.'
 [x] fromList(['lock', 'sock']) returns '[ls]ock'
 [x] fromList(['foo', 'afoo'], ["useLookahead" => true]) returns '(?=[af])a?foo'
 [x] fromList(['boast', 'boost']) returns 'bo[ao]st'
 [x] fromList(['pest', 'pst']) returns 'pe?st'
 [x] fromList(['boast', 'boost', 'bost']) returns 'bo[ao]?st'
 [x] fromList(['boost', 'best']) returns 'b(?:e|oo)st'
 [x] fromList(['boost', 'bst']) returns 'b(?:oo)?st'
 [x] fromList(['best', 'boost', 'bust']) returns 'b(?:[eu]|oo)st'
 [x] fromList(['boost', 'bst', 'cool']) returns '(?:b(?:oo)?st|cool)'
 [x] fromList(['boost', 'bst', 'cost']) returns '(?:b(?:oo)?|co)st'
 [x] fromList(['aax', 'aay', 'aax', 'aay']) returns 'aa[xy]'
 [x] fromList(['aaax', 'aaay', 'baax', 'baay']) returns '[ab]aa[xy]'
 [x] fromList(['aaax', 'aaay', 'bbaax', 'bbaay']) returns '(?:a|bb)aa[xy]'
 [x] fromList(['aaax', 'aaay', 'aax', 'aay']) returns 'aaa?[xy]'
 [x] fromList(['abx', 'aby', 'cdx', 'cdy']) returns '(?:ab|cd)[xy]'
 [x] fromList(['axx', 'ayy', 'bbxx', 'bbyy']) returns '(?:a|bb)(?:xx|yy)'
 [x] fromList(['axx', 'ayy', 'bbxx', 'bbyy', 'c']) returns '(?:c|(?:a|bb)(?:xx|yy))'
 [x] fromList(['axx', 'ayy', 'azz', 'bbxx', 'bbyy', 'c']) returns '(?:c|a(?:xx|yy|zz)|bb(?:xx|yy))'
 [x] fromList(['ac', 'af', 'bbc', 'bbf', 'c']) returns '(?:c|a[cf]|bb[cf])'
 [x] fromList(['^example.org$', '.example.org$', '^localhost$', '.localhost$'], ["specialChars" => ["^" => "^", "$" => "$"]]) returns '(?:\\.|^)(?:example\\.org|localhost)$'
 [x] fromList(['xixix', 'xoxox']) returns 'x(?:ixi|oxo)x'
 [x] fromList(['xixix', 'xixox', 'xoxox', 'xoxix']) returns 'x[io]x[io]x'
 [x] fromList(['afoo', 'abar', 'bbfoo', 'bbbar', 'a', 'bb']) returns '(?:a|bb)(?:bar|foo)?'
 [x] fromList(['ax', 'ay', 'bx', 'by']) returns '[ab][xy]'
 [x] fromList(['ax', 'ay', 'bx', 'by', 'c']) returns '(?:c|[ab][xy])'
 [x] fromList(['ax', 'ay', 'bx', 'by', 'x', 'y']) returns '[ab]?[xy]'
 [x] fromList(['ax', 'ay', 'bbx', 'bby', 'c']) returns '(?:c|a[xy]|bb[xy])'
 [x] fromList(['ax', 'ay', 'bx', 'by', 'c', 'ddx', 'ddy']) returns '(?:c|dd[xy]|[ab][xy])'
 [x] fromList(['']) returns ''
 [x] fromList(['', '']) returns ''
 [x] fromList(['ad', 'bd'], ["specialChars" => ["d" => "\\d"]]) returns '[ab]\\d'
 [x] fromList(['a', 'ax', 'ad', 'd', 'dx', 'dd'], ["specialChars" => ["d" => "\\d"]]) returns '[\\da][\\dx]?'
 [x] fromList(['foo', 'bar', 'y', 'z']) returns '(?:[yz]|bar|foo)'
 [x] fromList(['foo', 'bar', 'baz', 'y', 'z']) returns '(?:[yz]|ba[rz]|foo)'
 [x] fromList(['a', 'aacc', 'aadd', 'bbcc', 'bbdd']) returns '(?:a(?:a(?:cc|dd))?|bb(?:cc|dd))'
 [x] fromList(['aa', 'bb', 'aacc', 'aadd', 'bbcc', 'bbdd']) returns '(?:aa|bb)(?:cc|dd)?'
 [x] fromList(['aa', 'bb', 'aaccxx', 'aaddxx', 'bbccxx', 'bbddxx', 'aaccyy', 'aaddyy', 'bbccyy', 'bbddyy']) returns '(?:aa|bb)(?:(?:cc|dd)(?:xx|yy))?'
 [x] fromList(['^foo$', '^foo'], ["specialChars" => ["^" => "^", "$" => "$"]]) returns '^foo'
 [x] fromList(['^foo$', 'foo$'], ["specialChars" => ["^" => "^", "$" => "$"]]) returns 'foo$'
 [x] fromList(['bfoo', 'bfoob'], ["specialChars" => ["b" => "\\b"]]) returns '\\bfoo'
 [x] fromList(['apple', 'apple*'], ["specialChars" => ["*" => ".*?"]]) returns 'apple.*?'
 [x] fromList(['apple*', 'applepie'], ["specialChars" => ["*" => ".*?"]]) returns 'apple.*?'
 [x] fromList(['apple*', 'applepie'], ["specialChars" => ["*" => ".+?"]]) returns 'apple.+?'
 [x] fromList(['apple*', 'apple'], ["specialChars" => ["*" => ".*?"]]) returns 'apple.*?'
 [x] fromList(['apple*', 'apple+'], ["specialChars" => ["*" => ".*?", "+" => ".*"]]) returns 'apple.*'
 [x] fromList(['apple*', 'apple+'], ["specialChars" => ["*" => ".+?", "+" => ".+"]]) returns 'apple.+'
 [x] fromList(['apple*', 'apple+'], ["specialChars" => ["*" => ".*", "+" => ".+"]]) returns 'apple.*'
 [x] fromList(['applepie', 'lemonpie', 'pie', '*pie'], ["specialChars" => ["*" => ".*"]]) returns '.*pie'
 [x] fromList(['*pie*', 'lemonpie'], ["specialChars" => ["*" => ".*"]]) returns '.*pie.*'
 [x] fromList(['*pie*', 'lemonpie', 'banana'], ["specialChars" => ["*" => ".*"]]) returns '(?:.*pie.*|banana)'
 [x] fromList(['^foo$', '^foo+'], ["specialChars" => ["^" => "^", "$" => "$", "+" => ".+"]]) returns '^foo(?:$|.+)'
 [x] fromList(['^foo$', '^foo*'], ["specialChars" => ["^" => "^", "$" => "$", "*" => ".*"]]) returns '^foo.*'
 [x] fromList(['food', 'foo+'], ["specialChars" => ["d" => "\\d", "+" => ".+"]]) returns 'foo.+'
 [x] fromList(['foo*', 'foo+'], ["specialChars" => ["*" => "\\w*", "+" => ".+"]]) returns 'foo(?:\\w*|.+)'
 [x] fromList(['foo?', 'foo+'], ["specialChars" => ["?" => "\\w?", "+" => ".+"]]) returns 'foo(?:.+|\\w?)'
 [x] fromList(['fooB', 'foo+'], ["specialChars" => ["B" => "\\B", "+" => ".+"]]) returns 'foo(?:.+|\\B)'
 [x] fromList(['+foo+', 'fooB'], ["specialChars" => ["B" => "\\B", "+" => ".+"]]) returns '(?:.+foo.+|foo\\B)'
 [x] fromList(['+foo+', 'foo', 'bar'], ["specialChars" => ["+" => ".+"]]) returns '(?:.+foo.+|bar|foo)'
 [x] fromList(['+foo+', '+foo', 'bar'], ["specialChars" => ["+" => ".+"]]) returns '(?:.+foo.*|bar)'
 [x] fromList(['+foo+', '+foo'], ["specialChars" => ["+" => ".+"]]) returns '.+foo.*'
 [x] fromList(['++', 'a'], ["specialChars" => ["+" => ".+"]]) returns '(?:a|.+.+)'
 [x] fromList(['a', '.'], ["specialChars" => ["." => "."]]) returns '.'
 [x] fromList(['hip', 'hop', 'h.p'], ["specialChars" => ["." => "."]]) returns 'h.p'
 [x] fromList(['hi', 'hop', 'h.p'], ["specialChars" => ["." => "."]]) returns 'h(?:i|.p)'
 [x] fromList(['h', 'h.'], ["specialChars" => ["." => "."]]) returns 'h.?'
 [x] fromList(['h.', 'hd'], ["specialChars" => ["." => ".", "d" => "\\d\\d"]]) returns 'h(?:.|\\d\\d)'
 [x] fromList(['hXXXXXXXXXXX', 'h\\^$.[]()+*?', 'hotel'], ["specialChars" => ["X" => "."]]) returns 'h(?:...........|otel)'
 [x] fromList(['zdDhHsSvVwW', 'z..........', 'zebra'], ["specialChars" => ["d" => "\\d", "D" => "D", "h" => "\\h", "H" => "\\H", "s" => "\\s", "S" => "S", "v" => "\\v", "V" => "\\V", "w" => "\\w", "W" => "W", "." => "."]]) returns 'z(?:..........|ebra)'
 [x] fromList(['m.', 'mb'], ["specialChars" => ["." => ".", "b" => "\\b"]]) returns 'm(?:.|\\b)'
 [x] fromList(['m.', 'mB'], ["specialChars" => ["." => ".", "B" => "\\B"]]) returns 'm(?:.|\\B)'
 [x] fromList(['m.', 'mA'], ["specialChars" => ["." => ".", "A" => "\\A"]]) returns 'm(?:.|\\A)'
 [x] fromList(['m.', 'mZ'], ["specialChars" => ["." => ".", "Z" => "\\Z"]]) returns 'm(?:.|\\Z)'
 [x] fromList(['m.', 'mz'], ["specialChars" => ["." => ".", "z" => "\\z"]]) returns 'm(?:.|\\z)'
 [x] fromList(['m.', 'mG'], ["specialChars" => ["." => ".", "G" => "\\G"]]) returns 'm(?:.|\\G)'
 [x] fromList(['m.', 'mQ'], ["specialChars" => ["." => ".", "Q" => "\\Q"]]) returns 'm(?:.|\\Q)'
 [x] fromList(['m.', 'mE'], ["specialChars" => ["." => ".", "E" => "\\E"]]) returns 'm(?:.|\\E)'
 [x] fromList(['m.', 'mK'], ["specialChars" => ["." => ".", "K" => "\\K"]]) returns 'm(?:.|\\K)'
 [x] fromList(['h$', 'h.'], ["specialChars" => ["." => ".", "$" => "$"]]) returns 'h(?:$|.)'
 [x] fromList(['h?', 'ha'], ["specialChars" => ["?" => ".?"]]) returns 'h.?'
 [x] fromList(['h.', 'hi', 'hit'], ["specialChars" => ["." => ".?"]]) returns 'h(?:.|it)?'
 [x] fromList(['a.c.e', 'a.ce', 'ac.e', 'ace', 'acde', 'abce', 'abcde'], ["specialChars" => ["." => ".?"]]) returns 'a.?c.?e'
 [x] fromList(['h????', 'hello', 'heart'], ["specialChars" => ["?" => ".?"]]) returns 'h.?.?.?.?'
 [x] fromList(['x', 'xx', 'xxx']) returns 'xx?x?'
 [x] fromList(['d', 'dd', 'ddd'], ["specialChars" => ["d" => "\\d"]]) returns '\\d\\d?\\d?'
 [x] fromList() throws a RuntimeException if any word is not legal UTF-8

s9e\TextFormatter\Tests\Configurator\Helpers\RegexpConvertor
 [x] toJS() can convert plain regexps
 [x] toJS() escapes forward slashes
 [x] toJS() does not double-escape forward slashes that are already escaped
 [x] toJS() does not "eat" backslashes while escaping forward slashes
 [x] toJS() can convert regexps with the "i" modifier
 [x] toJS() can convert regexps with capturing subpatterns
 [x] toJS() can convert regexps with non-capturing subpatterns
 [x] toJS() can convert regexps with non-capturing subpatterns with a quantifier
 [x] toJS() converts greedy quantifiers to normal quantifiers in non-capturing subpatterns
 [x] toJS() throws a RuntimeException on options (?i)
 [x] toJS() throws a RuntimeException on subpattern options (?i:)
 [x] toJS() can convert regexps with character classes with a quantifier
 [x] toJS() converts greedy quantifiers to normal quantifiers in character classes
 [x] toJS() replaces \pL with the full character range in character classes
 [x] toJS() replaces \p{L} with the full character range in character classes
 [x] toJS() replaces \pL outside of character classes with a character class containing the full character range
 [x] toJS() replaces \p{L} outside of character classes with a character class containing the full character range
 [x] toJS() replaces \p{^L} with a character class containing the full character range
 [x] toJS() replaces \p{^L} with a character class equivalent to \PL
 [x] toJS() replaces \P{^L} with a character class equivalent to \pL
 [x] toJS() can convert regexps with lookahead assertions
 [x] toJS() can convert regexps with negative lookahead assertions
 [x] toJS() throws a RuntimeException on lookbehind assertions
 [x] toJS() throws a RuntimeException on negative lookbehind assertions
 [x] toJS() converts . to [\s\S] outside of character classes if the "s" modifier is set
 [x] toJS() does not convert . to [\s\S] if the "s" modifier is not set
 [x] toJS() does not convert . inside of character classes
 [x] toJS() converts named captures into normal captures
 [x] toJS() replaces its second parameter with an array that maps named captures to their index
 [x] toJS() correctly converts /(?:foo)(?<z>bar)/ to /(?:foo)(bar)/

s9e\TextFormatter\Tests\Configurator\Helpers\RegexpParser
 [x] parse() can parse plain regexps
 [x] parse() throws a RuntimeException if delimiters can't be parsed
 [x] parse() parses pattern modifiers
 [x] parse() parses character classes
 [x] parse() parses character classes with quantifiers
 [x] parse() parses character classes that end with an escaped ]
 [x] parse() throws a RuntimeException if a character class is not properly closed
 [x] parse() correctly parses escaped brackets
 [x] parse() correctly parses escaped parentheses
 [x] parse() parses non-capturing subpatterns
 [x] parse() parses non-capturing subpatterns with atomic grouping
 [x] parse() parses non-capturing subpatterns with quantifiers
 [x] parse() parses non-capturing subpatterns with options
 [x] parse() parses option settings
 [x] parse() parses named subpatterns using the (?<name>) syntax
 [x] parse() parses named subpatterns using the (?P<name>) syntax
 [x] parse() parses named subpatterns using the (?'name') syntax
 [x] parse() parses capturing subpatterns
 [x] parse() throws a RuntimeException if an unmatched right parenthesis is found
 [x] parse() throws a RuntimeException if an unmatched left parenthesis is found
 [x] parse() throws a RuntimeException on unsupported subpatterns
 [x] parse() parses lookahead assertions
 [x] parse() parses negative lookahead assertions
 [x] parse() parses lookbehind assertions
 [x] parse() parses negative lookbehind assertions

s9e\TextFormatter\Tests\Configurator\Helpers\RulesHelper
 [x] Works with a single tag
 [x] If no rule is defined, the default is to allow children and descendants
 [x] Correctly applies denyChild
 [x] defaultChildRule is correctly applied
 [x] allowChild overrides defaultChildRule('deny')
 [x] denyChild overrides defaultChildRule('allow')
 [x] denyChild overrides allowChild
 [x] denyDescendant overrides allowChild
 [x] defaultDescendantRule is correctly applied
 [x] allowDescendant overrides defaultDescendantRule('deny')
 [x] allowDescendant does not override denyChild
 [x] denyDescendant overrides defaultDescendantRule('allow')
 [x] denyDescendant overrides allowDescendant
 [x] denyAll (true) overrides everything
 [x] denyAll (false) has no effect
 [x] Tags with a requireParent rule are not allowed at the root
 [x] Tags that aren't allowed anywhere are omitted from the return array
 [x] Tags that are allowed in a closed dependency loop are omitted from the return array
 [x] Rules targeting inexistent tags do not interfere
 [x] Bitfields are compressed by making tags that are targeted by the same permissions share the same bit number

s9e\TextFormatter\Tests\Configurator\Helpers\TemplateOptimizer
 [x] Comments are removed
 [x] Superfluous whitespace between elements is removed
 [x] Single space characters are preserved
 [x] Superfluous whitespace inside tags is removed
 [x] Superfluous whitespace around XSL attributes is removed
 [x] Superfluous whitespace in simple attribute expressions is removed
 [x] Superfluous whitespace in @select expressions is removed
 [x] Whitespace is literal strings used in @select expressions is preserved
 [x] Superfluous whitespace in @test expressions is removed
 [x] Whitespace necessary to delimit names in @test expressions is preserved
 [x] Superfluous whitespace in XPath expressions in inline attributes is removed
 [x] Escaped curly brackets in inline attributes are preserved
 [x] <xsl:element/> is inlined where possible
 [x] Inlined elements' names are lowercased
 [x] <xsl:attribute/> with one single <xsl:value-of/> child is inlined
 [x] Inlined attributes' names are lowercased
 [x] <xsl:attribute/> with <xsl:value-of/>, <xsl:text/> and text nodes descendants is inlined
 [x] Curly brackets in text are escaped when attributes are inlined
 [x] <xsl:attribute/> with <xsl:if/> child is not inlined
 [x] Conditional <xsl:attribute/> is replaced with <xsl:copy-of/> where possible
 [x] Conditional <xsl:attribute/> is not replaced with <xsl:copy-of/> if names do not match
 [x] <xsl:text/> is inlined
 [x] <xsl:text> </xsl:text> is inlined
 [x] Attribute names are lowercased
 [x] Attributes are deduplicated and the first one of a given name is kept
 [x] Attributes are deduplicated and the first one of a given lowercased name is kept
 [x] Element names are lowercased
 [x] <xsl:if test="@foo"><xsl:value-of select="@foo"/></xsl:if> is optimized to <xsl:value-of select="@foo"/>
 [x] <xsl:if test="@foo"><xsl:value-of select="@bar"/></xsl:if> is left untouched
 [x] <xsl:if test="1+@foo"><xsl:value-of select="1+@foo"/></xsl:if> is left untouched
 [x] Throws an exception during XPath minification if a string isn't properly closed

s9e\TextFormatter\Tests\Configurator\Helpers\TemplateChecker
 [x] checkUnsafe() throws an exception on invalid XML
 [x] checkUnsafe() throws an exception if the template contains a <?php instruction
 [x] checkUnsafe() throws an exception if the template contains a <?PHP instruction
 [x] checkUnsafe() throws an exception if an element has an "use-attribute-sets" attribute
 [x] Not safe: <x:element name="script" xmlns:x="http://www.w3.org/1999/XSL/Transform"><xsl:apply-templates/></x:element>
 [x] Not safe: <element name="script" xmlns="http://www.w3.org/1999/XSL/Transform"><apply-templates/></element>
 [x] Safe if attribute 'email' has filter '#email': <a href="mailto:{@email}"/>
 [x] Safe if attribute 'email' has filter '#email': <a href="mailto:{@email}?subject=foo"/>
 [x] Unsafe even if attribute 'email' has filter '#email': <a href="http://{@email}"/>
 [x] Not safe: <embed src="{@url}"/>
 [x] Not safe: <iframe src="{@url}"/>
 [x] Not safe: <object data="{@url}"/>
 [x] Not safe: <script src="{@url}"/>
 [x] Not safe if attribute 'src' has filter '#url': <script src="{@url}"/>
 [x] Not safe: <script src="http://{@foo}"/>
 [x] Safe if attribute 'id' has filter '#number': <script src="https://gist.github.com/{@id}.js"/>
 [x] Not safe: <SCRIPT src="{@url}"/>
 [x] Not safe: <script SRC="{@url}"/>
 [x] Not safe: <script><xsl:attribute name="src"><xsl:value-of select="@url"/><?dont-optimize?></xsl:attribute></script>
 [x] Not safe: <script><xsl:attribute name="SRC"><xsl:value-of select="@url"/><?dont-optimize?></xsl:attribute></script>
 [x] Safe: <script><xsl:attribute name="src">http://example.org/legit.js<?dont-optimize?></xsl:attribute></script>
 [x] Safe: <script src="http://example.org/legit.js"><xsl:attribute name="id"><xsl:value-of select="foo"/><?dont-optimize?></xsl:attribute></script>
 [x] Not safe: <script src="http://example.org/legit.js"><xsl:attribute name="src"><xsl:value-of select="@hax"/><?dont-optimize?></xsl:attribute></script>
 [x] Not safe: <xsl:element name="script"><xsl:attribute name="src"><xsl:value-of select="@url"/><?dont-optimize?></xsl:attribute></xsl:element>
 [x] Not safe: <xsl:element name="SCRIPT"><xsl:attribute name="src"><xsl:value-of select="@url"/><?dont-optimize?></xsl:attribute></xsl:element>
 [x] Not safe: <object><param name="movie" value="{@url}"/></object>
 [x] Not safe: <OBJECT><PARAM NAME="MOVIE" VALUE="{@url}"/></OBJECT>
 [x] Not safe: <b disable-output-escaping="1"/>
 [x] Not safe: <xsl:copy/>
 [x] Not safe: <b><xsl:copy-of select="@onclick"/></b>
 [x] Not safe: <b><xsl:copy-of select=" @ onclick "/></b>
 [x] Safe: <b><xsl:copy-of select="@title"/></b>
 [x] Safe: <b><xsl:copy-of select=" @ title "/></b>
 [x] Not safe if attribute 'href' has no filter: <a><xsl:copy-of select="@href"/></a>
 [x] Safe if attribute 'href' has filter '#url': <a><xsl:copy-of select="@href"/></a>
 [x] Not safe: <xsl:copy-of select="script"/>
 [x] Not safe: <xsl:copy-of select=" script "/>
 [x] Not safe: <xsl:copy-of select="parent::*"/>
 [x] Not safe: <script><xsl:apply-templates/></script>
 [x] Not safe: <script><xsl:apply-templates select="st"/></script>
 [x] Not safe: <script><xsl:if test="1"><xsl:apply-templates/></xsl:if></script>
 [x] Not safe: <script><xsl:value-of select="st"/></script>
 [x] Not safe: <script><xsl:value-of select="@foo"/></script>
 [x] Not safe if attribute 'foo' has no filter: <script><xsl:value-of select="@foo"/></script>
 [x] Not safe if attribute 'foo' has no filter: <script><xsl:if test="1"><xsl:value-of select="@foo"/></xsl:if></script>
 [x] Not safe if attribute 'foo' has no filter: <xsl:element name="script"><xsl:value-of select="@foo"/></xsl:element>
 [x] Not safe if attribute 'foo' has no filter: <xsl:element name="SCRIPT"><xsl:value-of select="@foo"/></xsl:element>
 [x] Not safe if attribute 'foo' has filter 'json_encode': <script><xsl:for-each select="/*"><xsl:value-of select="@foo"/></xsl:for-each></script>
 [x] Safe if attribute 'foo' has filter 'json_encode': <script><xsl:value-of select="@foo"/></script>
 [x] Safe if attribute 'foo' has filter 'rawurlencode': <script><xsl:value-of select="@foo"/></script>
 [x] Safe if attribute 'foo' has filter 'strtotime': <script><xsl:value-of select="@foo"/></script>
 [x] Safe if attribute 'foo' has filter 'urlencode': <script><xsl:value-of select="@foo"/></script>
 [x] Safe if attribute 'foo' has filter '#url': <script><xsl:value-of select="@foo"/></script>
 [x] Safe if attribute 'foo' has filter '#int': <script><xsl:value-of select="@foo"/></script>
 [x] Safe if attribute 'foo' has filter '#uint': <script><xsl:value-of select="@foo"/></script>
 [x] Safe if attribute 'foo' has filter '#float': <script><xsl:value-of select="@foo"/></script>
 [x] Safe if attribute 'foo' has filter '#range': <script><xsl:value-of select="@foo"/></script>
 [x] Safe if attribute 'foo' has filter '#number': <script><xsl:value-of select="@foo"/></script>
 [x] Safe if attribute 'foo' has filter '#simpletext': <script><xsl:value-of select="@foo"/></script>
 [x] Not safe: <style><xsl:apply-templates/></style>
 [x] Not safe: <style><xsl:apply-templates select="st"/></style>
 [x] Not safe: <style><xsl:if test="1"><xsl:apply-templates/></xsl:if></style>
 [x] Not safe: <style><xsl:value-of select="st"/></style>
 [x] Not safe: <style><xsl:value-of select="@foo"/></style>
 [x] Not safe if attribute 'foo' has no filter: <style><xsl:value-of select="@foo"/></style>
 [x] Not safe if attribute 'foo' has no filter: <style><xsl:if test="1"><xsl:value-of select="@foo"/></xsl:if></style>
 [x] Not safe if attribute 'foo' has no filter: <xsl:element name="style"><xsl:value-of select="@foo"/></xsl:element>
 [x] Not safe if attribute 'foo' has no filter: <xsl:element name="STYLE"><xsl:value-of select="@foo"/></xsl:element>
 [x] Not safe if attribute 'foo' has filter '#url': <style><xsl:for-each select="/*"><xsl:value-of select="@foo"/></xsl:for-each></style>
 [x] Safe if attribute 'foo' has filter '#url': <style><xsl:value-of select="@foo"/></style>
 [x] Safe if attribute 'foo' has filter '#int': <style><xsl:value-of select="@foo"/></style>
 [x] Safe if attribute 'foo' has filter '#uint': <style><xsl:value-of select="@foo"/></style>
 [x] Safe if attribute 'foo' has filter '#float': <style><xsl:value-of select="@foo"/></style>
 [x] Safe if attribute 'foo' has filter '#color': <style><xsl:value-of select="@foo"/></style>
 [x] Safe if attribute 'foo' has filter '#range': <style><xsl:value-of select="@foo"/></style>
 [x] Safe if attribute 'foo' has filter '#number': <style><xsl:value-of select="@foo"/></style>
 [x] Safe if attribute 'foo' has filter '#simpletext': <style><xsl:value-of select="@foo"/></style>
 [x] Not safe: <xsl:element name="{FOO}"><xsl:apply-templates/></xsl:element>
 [x] Not safe: <b><xsl:attribute name="onclick"><xsl:apply-templates/></xsl:attribute></b>
 [x] Not safe: <b><xsl:attribute name="ONCLICK"><xsl:apply-templates/></xsl:attribute></b>
 [x] Not safe: <b onclick=""><xsl:attribute name="onclick"><xsl:apply-templates/></xsl:attribute></b>
 [x] Not safe: <b><xsl:if test="1"><xsl:attribute name="onclick"><xsl:value-of select="@foo"/></xsl:attribute></xsl:if></b>
 [x] Not safe: <b><xsl:attribute name="onclick"><xsl:if test="1"><xsl:value-of select="@foo"/></xsl:if></xsl:attribute></b>
 [x] Not safe: <b onclick="{@foo}"/>
 [x] Not safe: <b ONCLICK="{@foo}"/>
 [x] Not safe if attribute 'foo' has no filter: <b style="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#url': <b style="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#int': <b style="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#uint': <b style="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#float': <b style="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#color': <b style="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#range': <b style="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#number': <b style="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#simpletext': <b style="{@foo}"/>
 [x] Not safe if attribute 'foo' has no filter: <b onclick="{@foo}"/>
 [x] Safe if attribute 'foo' has filter 'json_encode': <b onclick="{@foo}"/>
 [x] Safe if attribute 'foo' has filter 'rawurlencode': <b onclick="{@foo}"/>
 [x] Safe if attribute 'foo' has filter 'strtotime': <b onclick="{@foo}"/>
 [x] Safe if attribute 'foo' has filter 'urlencode': <b onclick="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#url': <b onclick="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#int': <b onclick="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#uint': <b onclick="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#float': <b onclick="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#range': <b onclick="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#number': <b onclick="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#simpletext': <b onclick="{@foo}"/>
 [x] Not safe if attribute 'foo' has no filter: <b onanything="{@foo}"/>
 [x] Safe if attribute 'foo' has filter 'json_encode': <b onanything="{@foo}"/>
 [x] Safe if attribute 'foo' has filter 'rawurlencode': <b onanything="{@foo}"/>
 [x] Safe if attribute 'foo' has filter 'strtotime': <b onanything="{@foo}"/>
 [x] Safe if attribute 'foo' has filter 'urlencode': <b onanything="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#url': <b onanything="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#int': <b onanything="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#uint': <b onanything="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#float': <b onanything="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#range': <b onanything="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#number': <b onanything="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#simpletext': <b onanything="{@foo}"/>
 [x] Not safe if attribute 'foo' has no filter: <form action="{@foo}"/>
 [x] Safe if attribute 'foo' has filter 'urlencode': <form action="{@foo}"/>
 [x] Safe if attribute 'foo' has filter 'rawurlencode': <form action="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#url': <form action="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#id': <form action="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#int': <form action="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#uint': <form action="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#float': <form action="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#range': <form action="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#number': <form action="{@foo}"/>
 [x] Not safe if attribute 'foo' has no filter: <q cite="{@foo}"/>
 [x] Safe if attribute 'foo' has filter 'urlencode': <q cite="{@foo}"/>
 [x] Safe if attribute 'foo' has filter 'rawurlencode': <q cite="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#url': <q cite="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#id': <q cite="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#int': <q cite="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#uint': <q cite="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#float': <q cite="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#range': <q cite="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#number': <q cite="{@foo}"/>
 [x] Not safe if attribute 'foo' has no filter: <xbject data="{@foo}"/>
 [x] Safe if attribute 'foo' has filter 'urlencode': <xbject data="{@foo}"/>
 [x] Safe if attribute 'foo' has filter 'rawurlencode': <xbject data="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#url': <xbject data="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#id': <xbject data="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#int': <xbject data="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#uint': <xbject data="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#float': <xbject data="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#range': <xbject data="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#number': <xbject data="{@foo}"/>
 [x] Not safe if attribute 'foo' has no filter: <input formaction="{@foo}"/>
 [x] Safe if attribute 'foo' has filter 'urlencode': <input formaction="{@foo}"/>
 [x] Safe if attribute 'foo' has filter 'rawurlencode': <input formaction="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#url': <input formaction="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#id': <input formaction="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#int': <input formaction="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#uint': <input formaction="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#float': <input formaction="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#range': <input formaction="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#number': <input formaction="{@foo}"/>
 [x] Not safe if attribute 'foo' has no filter: <a href="{@foo}"/>
 [x] Safe if attribute 'foo' has filter 'urlencode': <a href="{@foo}"/>
 [x] Safe if attribute 'foo' has filter 'rawurlencode': <a href="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#url': <a href="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#id': <a href="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#int': <a href="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#uint': <a href="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#float': <a href="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#range': <a href="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#number': <a href="{@foo}"/>
 [x] Not safe if attribute 'foo' has no filter: <html manifest="{@foo}"/>
 [x] Safe if attribute 'foo' has filter 'urlencode': <html manifest="{@foo}"/>
 [x] Safe if attribute 'foo' has filter 'rawurlencode': <html manifest="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#url': <html manifest="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#id': <html manifest="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#int': <html manifest="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#uint': <html manifest="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#float': <html manifest="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#range': <html manifest="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#number': <html manifest="{@foo}"/>
 [x] Not safe if attribute 'foo' has no filter: <video poster="{@foo}"/>
 [x] Safe if attribute 'foo' has filter 'urlencode': <video poster="{@foo}"/>
 [x] Safe if attribute 'foo' has filter 'rawurlencode': <video poster="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#url': <video poster="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#id': <video poster="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#int': <video poster="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#uint': <video poster="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#float': <video poster="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#range': <video poster="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#number': <video poster="{@foo}"/>
 [x] Not safe if attribute 'foo' has no filter: <img src="{@foo}"/>
 [x] Safe if attribute 'foo' has filter 'urlencode': <img src="{@foo}"/>
 [x] Safe if attribute 'foo' has filter 'rawurlencode': <img src="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#url': <img src="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#id': <img src="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#int': <img src="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#uint': <img src="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#float': <img src="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#range': <img src="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#number': <img src="{@foo}"/>
 [x] Not safe if attribute 'foo' has no filter: <img lowsrc="{@foo}"/>
 [x] Safe if attribute 'foo' has filter 'urlencode': <img lowsrc="{@foo}"/>
 [x] Safe if attribute 'foo' has filter 'rawurlencode': <img lowsrc="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#url': <img lowsrc="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#id': <img lowsrc="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#int': <img lowsrc="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#uint': <img lowsrc="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#float': <img lowsrc="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#range': <img lowsrc="{@foo}"/>
 [x] Safe if attribute 'foo' has filter '#number': <img lowsrc="{@foo}"/>
 [x] Not safe: <b><xsl:attribute name="{FOO}"><xsl:apply-templates/></xsl:attribute></b>

s9e\TextFormatter\Tests\Configurator\Helpers\TemplateHelper
 [x] loadTemplate() can load 'foo'
 [x] saveTemplate() correctly handles 'foo'
 [x] loadTemplate() can load '<xsl:value-of select="@foo"/>'
 [x] saveTemplate() correctly handles '<xsl:value-of select="@foo"/>'
 [x] saveTemplate() correctly handles an empty string
 [x] loadTemplate() can load '<ul><li>one<li>two</ul>'
 [x] saveTemplate() correctly handles '<ul><li>one<li>two</ul>'
 [x] loadTemplate() throws an exception on malformed XSL
 [x] normalize() normalizes '<br>' to '<br/>'
 [x] normalize() throws an exception on malformed XSL

s9e\TextFormatter\Tests\Configurator\Items\Attribute
 [x] An array of options can be passed to the constructor
 [x] $attr->filterChain can be assigned an array
 [x] $attr->filterChain can be assigned an instance of FilterChain to copy its content
 [x] setFilterChain() throws an InvalidArgumentException if its argument is not an array or an instance of FilterChain
 [x] $attr->generator accepts an instance of ProgrammableCallback
 [x] $attr->generator accepts a callback and normalizes it to an instance of ProgrammableCallback
 [x] asConfig() correctly produces a config array

s9e\TextFormatter\Tests\Configurator\Items\AttributePreprocessor
 [x] __construct() throws an InvalidArgumentException if the regexp is not valid
 [x] getAttributes() returns an array where keys are the name of the named subpatterns/attributes and values is the regexp that exactly matches them
 [x] getAttributes() preserves the original's regexp "i", "s" and "u" flags
 [x] getRegexp() returns the regexp associated with this attribute preprocessor

s9e\TextFormatter\Tests\Configurator\Items\CallbackPlaceholder
 [x] Is callable
 [x] Throws an exception if invoked
 [x] asConfig() returns the value passed to the constructor

s9e\TextFormatter\Tests\Configurator\Items\ProgrammableCallback
 [x] __construct() throws an InvalidArgumentException if its argument is not callable
 [x] An array of variables can be set with setVars() or retrieved with getVars()
 [x] addParameterByValue() adds a parameter as a value with no name
 [x] addParameterByName() adds a parameter as a name with no value
 [x] Callback ['foo','bar'] is normalized to 'foo::bar'
 [x] getCallback() returns the callback
 [x] fromArray() creates an instance from an array
 [x] fromArray() accepts the name of a built-in filter as callback
 [x] asConfig() returns an array containing the callback
 [x] asConfig() replaces the by-name parameters by the values stored in vars if available
 [x] If the callback is an instance of CallbackPlaceholder, asConfig() calls the callback's asConfig() and returns its value as callback
 [x] asConfig() returns the vars set with setVars() if the callback is an instance of CallbackPlaceholder

s9e\TextFormatter\Tests\Configurator\Items\Tag
 [x] An array of options can be passed to the constructor
 [x] $tag->attributePreprocessors can be assigned a 2D array of regexps
 [x] $tag->attributePreprocessors can be assigned an instance of AttributePreprocessorCollection to copy its content
 [x] Setting $tag->attributePreprocessors clears previous attributePreprocessors
 [x] $tag->nestingLimit accepts '10' and casts it as an integer
 [x] $tag->nestingLimit rejects non-numbers
 [x] $tag->nestingLimit rejects numbers less than 1
 [x] $tag->rules can be assigned a 2D array of rules
 [x] $tag->rules can be assigned an instance of Ruleset to copy its content
 [x] Setting $tag->rules clears previous rules
 [x] $tag->tagLimit accepts '10' and casts it as an integer
 [x] $tag->tagLimit rejects non-numbers
 [x] $tag->tagLimit rejects numbers less than 1
 [x] $tag->templates can be assigned an array of templates
 [x] $tag->templates can be assigned an instance of TemplateCollection to copy its content
 [x] Setting $tag->templates clears previous templates
 [x] setTemplates() throws an InvalidArgumentException if its argument is not an array or an instance of TemplateCollection
 [x] $tag->defaultTemplate maps to $tag->templates->get('')
 [x] $tag->defaultTemplate = 'foo' maps to $tag->templates->set('', 'foo')
 [x] asConfig() produces a config array, omitting properties that are not needed during parsing: defaultChildRule, defaultDescendantRule and templates
 [x] $tag->filterChain contains the built-in filter '#executeAttributePreprocessors' by default
 [x] $tag->filterChain contains the built-in filter '#filterAttributes' by default
 [x] asConfig() omits '#executeAttributePreprocessors' from the returned filterChain if no attribute preprocessor is defined
 [x] asConfig() does not modify the tag's filterChain itself

s9e\TextFormatter\Tests\Configurator\Items\Template
 [x] Template::__construct() accepts a string
 [x] Template::__construct() accepts a valid callback
 [x] Template::__construct() throws an exception on anything else
 [x] When cast as string, returns the string passed to constructor if applicable
 [x] When cast as string, executes the callback passed to constructor and returns its result if applicable

s9e\TextFormatter\Tests\Configurator\Stylesheet
 [x] setOutputMethod('xml') sets the stylesheet's output method to 'xml'
 [x] setOutputMethod('text') throws an exception
 [x] setWildcardTemplate() accepts a string as template
 [x] setWildcardTemplate() accepts a callback as template
 [x] setWildcardTemplate() accepts an instance of Template as template
 [x] setWildcardTemplate() rejects anything else
 [x] setWildcardTemplate() sets a template with a * matching rule for given prefix
 [x] setWildcardTemplate() throws an exception if the prefix is empty
 [x] setWildcardTemplate() throws an exception if the prefix is invalid
 [x] get() tests the wildcard templates' safeness
 [x] get() only tests the wildcard templates' safeness against tags in its namespace
 [x] get() only tests the wildcard templates' safeness against tags that do not have a default template
 [x] get() minifies predicates
 [x] get() correctly escapes predicates
 [x] get() merges duplicate templates
 [x] get() represents empty templates with a self-closing element
 [x] get() generates the namespace declarations necessary for prefixed tags
 [x] get() generates an exclude-result-prefixes directive for all the declared prefixes

s9e\TextFormatter\Tests\Configurator\UrlConfig
 [x] Disallowed IDNs are punycoded
 [x] disallowHost('example.org') disallows "example.org"
 [x] disallowHost('example.org') disallows "EXAMPLE.ORG"
 [x] disallowHost('example.org') disallows "www.example.org"
 [x] disallowHost('example.org') does not disallow "myexample.org"
 [x] disallowHost('example.org', false) does not disallow "www.example.org"
 [x] disallowHost('*.example.org') disallows "www.example.org"
 [x] disallowHost('*.example.org') disallows "www.xxx.example.org"
 [x] disallowHost('*.example.org') does not disallow "example.org"
 [x] disallowHost('*.example.org') does not disallow "example.org.org"
 [x] disallowHost('*xxx*') disallows "xxx.com"
 [x] disallowHost('*xxx*') disallows "foo.xxx"
 [x] disallowHost('*xxx*') disallows "myxxxsite.com"
 [x] resolveRedirectsFrom('bit.ly') matches "bit.ly"
 [x] resolveRedirectsFrom('bit.ly') matches "foo.bit.ly"
 [x] resolveRedirectsFrom('bit.ly', false) does not match "foo.bit.ly"
 [x] "http" is an allowed scheme by default
 [x] "https" is an allowed scheme by default
 [x] "HTTPS" is an allowed scheme by default
 [x] "ftp" is an allowed scheme by default
 [x] getAllowedSchemes() returns an array containing all the allowed schemes
 [x] allowScheme('ftp') allows "ftp" as scheme
 [x] allowScheme('<invalid>') throws an exception
 [x] There is no default scheme by default
 [x] setDefaultScheme('http') sets "http" as default scheme
 [x] setDefaultScheme('<invalid>') throws an exception
 [x] URLs do not require a scheme by default
 [x] requireScheme() forces URLs to require a scheme
 [x] requireScheme('nonbool') throws an exception

s9e\TextFormatter\Tests\Configurator\Validators\AttributeName
 [x] normalize() throws an InvalidArgumentException if the name is invalid
 [x] "url" is normalized to "url"
 [x] "URL" is normalized to "url"
 [x] "_url" is normalized to "_url"
 [x] "md5" is normalized to "md5"
 [x] "5md" is invalid (name must start with a letter or an underscore)
 [x] "" is invalid (name must start with a letter or an underscore)
 [x] "xmlns" is invalid ('xmlns' is reserved)
 [x] "data-src" is normalized to "data-src"
 [x] "foo:bar" is invalid (no colons allowed)
 [x] "foo\n" is invalid (no newlines allowed)

s9e\TextFormatter\Tests\Configurator\Validators\TagName
 [x] normalize() throws an InvalidArgumentException if the name is invalid
 [x] "b" is normalized to "B"
 [x] "B" is normalized to "B"
 [x] "_b" is normalized to "_B"
 [x] "H1" is normalized to "H1"
 [x] "-H" is invalid (name must start with a letter or an underscore)
 [x] "1H" is invalid (name must start with a letter or an underscore)
 [x] "" is invalid (name must start with a letter or an underscore)
 [x] "foo-bar" is normalized to "FOO-BAR"
 [x] "foo#bar" is invalid (no pound sign allowed)
 [x] "foo:bar" is normalized to "foo:bar"
 [x] ":bar" is invalid (empty prefix)
 [x] "_foo:bar" is normalized to "_foo:bar"
 [x] "Foo:bar" is normalized to "Foo:bar"
 [x] "f00:b4r" is normalized to "f00:b4r"
 [x] "foo_bar:baz" is normalized to "foo_bar:baz"
 [x] "7up:foo" is invalid (prefix must start with a letter)
 [x] "foo:bar:baz" is invalid (only one colon allowed)
 [x] "xmlns:foo" is invalid ('xmlns' prefix is reserved)
 [x] "xsl:foo" is invalid ('xsl' prefix is reserved)
 [x] "s9e:foo" is invalid ('s9e' prefix is reserved)
 [x] "B\n" is invalid (no newlines allowed)

s9e\TextFormatter\Tests\Parser\BuiltInFilters
 [x] Regression tests
 [x] Filters work

s9e\TextFormatter\Tests\Parser\FilterProcessing
 [x] registerVar($k, $v) sets registeredVars[$k] to $v
 [x] executeAttributePreprocessors() sets captured attributes on match
 [x] executeAttributePreprocessors() does not overwrite attributes that were already set
 [x] executeAttributePreprocessors() unsets the source attribute on match
 [x] executeAttributePreprocessors() does not unset the source attribute if there's nn match
 [x] executeAttributePreprocessors() stops after the first match
 [x] executeAttributePreprocessors() tries all preprocessors until there's a match
 [x] executeAttributePreprocessors() returns TRUE even if the no source attribute was present
 [x] executeFilter() correctly passes a value to the callback
 [x] executeFilter() correctly passes a named var to the callback
 [x] executeFilter() correctly passes a var passed through registeredVars to the callback
 [x] executeFilter() does not execute the callback and returns FALSE if a variable is missing
 [x] executeFilter() logs an error if a variable is missing
 [x] filterTag() returns TRUE if the tag has an empty filterChain
 [x] filterTag() executes the tag's filterChain and returns TRUE
 [x] filterTag() stops executing the tag's filterChain and returns FALSE if a filter returns FALSE
 [x] filterTag() calls the logger's setTag() and unsetTag() methods
 [x] filterAttributes() removes the tag's attributes if none were configured
 [x] filterAttributes() calls the attribute's generator and uses its return value as attribute's value
 [x] filterAttributes() removes undefined attributes
 [x] filterAttributes() executes every filter of an attribute's filterChain and returns the value
 [x] filterAttributes() stops executing the attribute's filterChain and returns FALSE if a filter returns FALSE
 [x] filterAttributes() removes invalid attributes
 [x] filterAttributes() replaces invalid attributes with their defaultValue if applicable
 [x] filterAttributes() adds missing attributes with their defaultValue if applicable
 [x] filterAttributes() calls the logger's setAttribute() and unsetAttribute() methods for each attribute with a filterChain

s9e\TextFormatter\Tests\Parser\Logger
 [x] debug() generates a "debug" entry in the logs
 [x] err() generates a "err" entry in the logs
 [x] info() generates a "info" entry in the logs
 [x] warn() generates a "warn" entry in the logs
 [x] The attribute name set by setAttribute() is added to the context if no 'attrName' element is provided
 [x] The attribute name set by setAttribute() is not added to the context if an 'attrName' element is provided
 [x] unsetAttribute() unsets the value stored by setAttribute()
 [x] The tag set by setTag() is added to the context if no 'tag' element is provided
 [x] The tag set by setTag() is not added to the context if a 'tag' element is provided
 [x] unsetTag() unsets the value stored by setTag()
 [x] clear() empties the logs
 [x] on() attaches a callback to be executed when the corresponding log type is used
 [x] on() throws an exception on invalid callback
 [x] on() callbacks receive the log message and its context
 [x] on() callbacks can modify the log message and its context if their signature accepts them as a reference
 [x] on() callbacks are only executed for the log type they were registered for

s9e\TextFormatter\Tests\Parser\PluginsHandling
 [x] disablePlugin() disables given plugin
 [x] enablePlugin() re-enables a disabled plugin
 [x] Nothing happens if disablePlugin() is called for an inexistent plugin
 [x] Nothing happens if enablePlugin() is called for an inexistent plugin
 [x] executePluginParsers() executes plugins' parse() method
 [x] executePluginParsers() does not execute disabled plugins
 [x] executePluginParsers() executes a plugin if its quickMatch test passes
 [x] executePluginParsers() does not execute a plugin if its quickMatch test fails
 [x] executePluginParsers() executes a plugin if its regexp test passes
 [x] executePluginParsers() does not execute a plugin if its regexp test fails
 [x] executePluginParsers() passes the text and the matches to the plugin's parser
 [x] executePluginParsers() does not execute a plugin and throws a RuntimeException if the number of matches exceeds regexpLimit and regexpLimitAction is 'abort'
 [x] executePluginParsers() executes a plugin with the first regexpLimit number of matches and logs a warning if the number of matches exceeds regexpLimit and regexpLimitAction is neither 'abort' or 'ignore'
 [x] executePluginParsers() executes a plugin with the first regexpLimit number of matches if the number of matches exceeds regexpLimit and regexpLimitAction is neither 'ignore'
 [x] executePluginParsers() creates an instance of the class name stored in className if present

s9e\TextFormatter\Tests\Parser\Tag
 [x] getAttributes() returns the tag's attributes as an array
 [x] getEndTag() returns false if the tag has no end tag set
 [x] getPos() returns the tag's length (amount of text consumed)
 [x] getName() returns the tag's name
 [x] getPos() returns the tag's position
 [x] getSortPriority() returns the tag's sortPriority
 [x] getStartTag() returns false if the tag has no start tag set
 [x] getType() returns the tag's type
 [x] isInvalid() returns false by default
 [x] isBrTag() returns true if the tag's name is "br"
 [x] isBrTag() returns false by default
 [x] isIgnoreTag() returns true if the tag's name is "i"
 [x] isIgnoreTag() returns false by default
 [x] isStartTag() returns true if the tag's type is Tag::START_TAG
 [x] isStartTag() returns true if the tag's type is Tag::END_TAG
 [x] isStartTag() returns true if the tag's type is Tag::SELF_CLOSING_TAG
 [x] isEndTag() returns false if the tag's type is Tag::START_TAG
 [x] isEndTag() returns true if the tag's type is Tag::END_TAG
 [x] isEndTag() returns true if the tag's type is Tag::SELF_CLOSING_TAG
 [x] isSelfClosingTag() returns false if the tag's type is Tag::START_TAG
 [x] isSelfClosingTag() returns false if the tag's type is Tag::END_TAG
 [x] isSelfClosingTag() returns true if the tag's type is Tag::SELF_CLOSING_TAG
 [x] invalidate() makes isInvalid() return true
 [x] $tag1->cascadeInvalidationTo($tag2) causes $tag1->invalidate() to call $tag2->invalidate()
 [x] $tag1->cascadeInvalidationTo($tag2) does not cause $tag2->invalidate() to call $tag1->invalidate()
 [x] $tag1->cascadeInvalidationTo($tag2) immediately calls $tag2->invalidate() if $tag1 is invalid
 [x] Mutual invalidation doesn't cause an infinite loop
 [x] $tag1->pairWith($tag2) does not do anything if the tags have different names
 [x] $startTag->pairWith($endTag) does not do anything if $startTag's position is greater than $endTag's
 [x] $startTag->pairWith($endTag) sets $endTag->startTag if they share the same position
 [x] $startTag->pairWith($endTag) sets $endTag->startTag if $endTag's position is greater than $startTag's
 [x] $startTag->pairWith($endTag) sets $startTag->endTag if they share the same position
 [x] $startTag->pairWith($endTag) sets $startTag->endTag if $endTag's position is greater than $startTag's
 [x] $endTag->pairWith($startTag) sets $endTag->startTag if they share the same position
 [x] $endTag->pairWith($startTag) sets $endTag->startTag if $endTag's position is greater than $startTag's
 [x] $endTag->pairWith($startTag) sets $startTag->endTag if they share the same position
 [x] $endTag->pairWith($startTag) sets $startTag->endTag if $endTag's position is greater than $startTag's
 [x] setSortPriority() sets the tag's sortPriority
 [x] setAttribute('foo', 'bar') sets attribute 'foo' to 'bar'
 [x] setAttribute() overwrites existing attributes
 [x] setAttributes() sets multiple attributes at once
 [x] setAttributes() removes all other attributes
 [x] getAttribute('foo') returns the value of attribute 'foo'
 [x] hasAttribute('foo') returns false if attribute 'foo' is not set
 [x] hasAttribute('foo') returns true if attribute 'foo' is set
 [x] removeAttribute('foo') unsets attribute 'foo'

s9e\TextFormatter\Tests\Parser\TagStack
 [x] addStartTag() adds a start tag to the stack
 [x] addEndTag() adds an end tag to the stack
 [x] addSelfClosingTag() adds a self-closing tag to the stack
 [x] addStartTag() returns the newly added tag
 [x] addStartTag() does not add anything to the stack if the tag name does not exist but it returns an invalidated tag
 [x] addStartTag() does not add anything to the stack if the position is negative but it returns an invalidated tag
 [x] addStartTag() does not add anything to the stack if the length is negative but it returns an invalidated tag
 [x] addBrTag() adds a zero-width, self-closing "br" tag to the stack then returns it
 [x] addIgnoreTag() adds self-closing "i" tag to the stack then returns it
 [x] sortTags() sorts tags by position descending (tags processed in text order)
 [x] sortTags() tiebreaker sorts zero-width tags after longer tags at the same position (zero-width tags are processed first)
 [x] sortTags() tiebreaker sorts zero-width end tags after zero width start tag (end tags get the opportunity to close their parent before a new tag is open)
 [x] sortTags() tiebreaker sorts zero-width self-closing tags between zero-width start tags and zero-width end tags (attempting to keep them outside of tag pairs)
 [x] sortTags() tiebreaker sorts tags by length ascending (longer tags processed first)
 [x] sortTags() tiebreaker sorts tag by sortPriority descending (-10 is processed before 10)

s9e\TextFormatter\Tests\Parser
 [x] Parser is serializable
 [x] Parser can be unserialized
 [x] getLogger() returns an instance of Logger
 [x] parse() returns the intermediate representation
 [x] parse() can be called multiple times in succession

s9e\TextFormatter\Tests\Plugins\ConfiguratorBase
 [x] Constructor overwrites properties with values passed as second argument
 [x] Constructor calls setFoo() if 'foo' is being set
 [x] An exception is thrown if an unknown property is being set by the constructor
 [x] getBaseProperties() return the values of quickMatch, regexpLimit and regexpLimitAction
 [x] setQuickMatch() sets the quickMatch property
 [x] setQuickMatch() throws an exception on non-strings
 [x] disableQuickMatch() sets the quickMatch property to false
 [x] setRegexpLimit() sets the regexpLimit property
 [x] setRegexpLimit() throws an exception on invalid values
 [x] setRegexpLimitAction() sets the regexpLimitAction property
 [x] setRegexpLimitAction() throws an exception on invalid values
 [x] Offers a default asConfig() implementation that leaves out the configurator instance
 [x] toJS() converts the regexp in 'regexp' if applicable
 [x] toJS() converts the array of regexps in 'regexp' if applicable

s9e\TextFormatter\Tests\Plugins\ParserBase
 [x] Constructor calls setUp()
 [x] Constructor sets up $this->config and $this->parser before calling setUp()

s9e\TextFormatter\Tests\Plugins\Autoemail\Configurator
 [x] Automatically creates an "EMAIL" tag with an "email" attribute with a "#email" filter
 [x] Does not attempt to create a tag if it already exists
 [x] The name of the tag used can be changed through the "tagName" constructor option
 [x] The name of the attribute used can be changed through the "attrName" constructor option
 [x] Has a quickMatch
 [x] Generates a regexp for its config array
 [x] The config array contains the name of the tag
 [x] The config array contains the name of the attribute

s9e\TextFormatter\Tests\Plugins\Autoemail\Parser
 [x] Parsing tests
 [x] Parsing+rendering tests

s9e\TextFormatter\Tests\Plugins\Autolink\Configurator
 [x] Automatically creates an "URL" tag with an "url" attribute with a "#url" filter
 [x] Does not attempt to create a tag if it already exists
 [x] The name of the tag used can be changed through the "tagName" constructor option
 [x] The name of the attribute used can be changed through the "attrName" constructor option
 [x] Has a quickMatch
 [x] Generates a regexp for its config array
 [x] The config array contains the name of the tag
 [x] The config array contains the name of the attribute
 [x] The regexp matches the URL in 'foo http://www.bar.com baz'
 [x] The regexp matches the URL in 'FOO HTTP://WWW.BAR.COM BAZ'
 [x] The regexp matches the URL in 'foo http://www.bar.com/index.php?arr[foo]=1 baz'
 [x] The regexp matches the URL in 'foo [http://www.bar.com/index.php?foo=1] baz'
 [x] The regexp matches the URL in 'foo [http://www.bar.com/index.php?arr[foo]=1] baz'

s9e\TextFormatter\Tests\Plugins\Autolink\Parser
 [x] Parsing tests
 [x] Parsing+rendering tests

s9e\TextFormatter\Tests\Plugins\BBCodes\Configurator\AttributeValueCollection
 [x] Throws an exception on invalid attribute name

s9e\TextFormatter\Tests\Plugins\BBCodes\Configurator\BBCode
 [x] An array of options can be passed to the constructor
 [x] BBCode::normalizeName('*') returns '*'
 [x] BBCode::normalizeName('foo') returns 'FOO'
 [x] BBCode::normalizeName('*invalid*') throws an exception
 [x] defaultAttribute accepts an attribute name and normalizes it accordingly
 [x] tagName accepts a tag name and normalizes it accordingly
 [x] $bbcode->contentAttributes is an instance of AttributeList
 [x] $bbcode->predefinedAttributes is an instance of AttributeValueCollection
 [x] asConfig() returns its set properties

s9e\TextFormatter\Tests\Plugins\BBCodes\Configurator\BBCodeCollection
 [x] add() returns an instance of s9e\TextFormatter\Plugins\BBCodes\Configurator\BBCode
 [x] Instances of s9e\TextFormatter\Plugins\BBCodes\Configurator\BBCode are added as-is
 [x] add() normalizes the BBCode's name
 [x] delete() normalizes the BBCode's name
 [x] exists() normalizes the BBCode's name
 [x] get() normalizes the BBCode's name
 [x] set() normalizes the BBCode's name
 [x] asConfig() removes the defaultAttribute value of BBCodes where it is the same as the BBCode's name
 [x] asConfig() removes the tagName value of BBCodes where it is the same as the BBCode's name

s9e\TextFormatter\Tests\Plugins\BBCodes\Configurator\BBCodeMonkey
 [x] parse() works
 [x] replaceTokens() works

s9e\TextFormatter\Tests\Plugins\BBCodes\Configurator\Repository
 [x] __construct() accepts the path to an XML file as argument
 [x] __construct() accepts a DOMDocument as argument
 [x] __construct() throws an exception if passed anything else
 [x] __construct() throws an exception if passed the path to a file that is not valid XML
 [x] get() throws an exception if the BBCode is not in repository
 [x] get() normalizes the name before retrieval
 [x] If the name is a BBCode name followed by a # character, get() normalizes only the first part
 [x] Variables in <usage/> are replaced
 [x] Variables in <template/> are replaced
 [x] Variables that are not replaced are left intact
 [x] Custom tagName is correctly set
 [x] Rules targetting tags are correctly set
 [x] Boolean rules are set to their default value
 [x] Multiple templates can be set
 [x] predefinedAttributes is correctly set

s9e\TextFormatter\Tests\Plugins\BBCodes\Configurator\RepositoryCollection
 [x] Instances of Repository are added as-is
 [x] Anything else gets a new instance of Repository to be created

s9e\TextFormatter\Tests\Plugins\BBCodes\Configurator
 [x] Automatically loads its default BBCode repository
 [x] addFromRepository('B') adds BBCode B and its tag from the default repository
 [x] addFromRepository('MYBOLD', 'foo') adds BBCode B and its tag from the 'foo' repository
 [x] addFromRepository('B', 'foo', ['title' => 'bar']) adds BBCode B and its tag from the 'foo' repository with variable 'title' replaced with content 'bar'
 [x] addFromRepository('B', 'foo') throws an exception if repository 'foo' does not exist
 [x] addFromRepository() throws an exception if the BBCode already exists
 [x] addFromRepository() throws an exception if the tag already exists
 [x] addFromRepository() returns the newly-created BBCode
 [x] addCustom() returns the newly-created BBCode
 [x] asConfig() returns FALSE if no BBCodes were created
 [x] Has a quickMatch
 [x] Generates a regexp for its config array
 [x] The regexp that matches BBCode names does not contain a superfluous non-capturing subpattern
 [x] Essential non-capturing subpatterns are preserved

s9e\TextFormatter\Tests\Plugins\BBCodes\Parser
 [x] Parsing tests

s9e\TextFormatter\Tests\Plugins\Censor\Configurator
 [x] Automatically creates a "CENSOR" tag
 [x] Automatically creates a "with" attribute with required=false
 [x] Does not attempt to create a tag if it already exists
 [x] The name of the tag used can be changed through the "tagName" constructor option
 [x] The name of the attribute used can be changed through the "attrName" constructor option
 [x] asConfig() returns FALSE if no words were added
 [x] Generates a regexp for its config array
 [x] The config array contains the name of the tag
 [x] The config array contains the name of the attribute
 [x] Returns the replacements in its config in the form [regexp => replacement]
 [x] Words sharing the same replacement share a common regexp
 [x] Words using the default replacement do not appear in the replacements

s9e\TextFormatter\Tests\Plugins\Censor\Parser
 [x] Parsing tests
 [x] Parsing+rendering tests

s9e\TextFormatter\Tests\Plugins\Emoticons\Configurator
 [x] Automatically creates an "E" tag
 [x] Does not attempt to create a tag if it already exists
 [x] The name of the tag used can be changed through the "tagName" constructor option
 [x] set(':)', '<img src="e.png"/>') creates a :) emoticon that maps to <img src="e.png"/>
 [x] set(':)', '<img src="e.png">') creates a :) emoticon that maps to <img src="e.png"/>
 [x] Emoticons can contain single quotes
 [x] Emoticons can contain double quotes
 [x] Emoticons can contain both quotes at once
 [x] asConfig() returns FALSE if no emoticons were set
 [x] Generates a regexp for its config array
 [x] The config array contains the name of the tag
 [x] asConfig() generates a quickMatch if applicable

s9e\TextFormatter\Tests\Plugins\Emoticons\Configurator\EmoticonCollection
 [x] Normalizes HTML templates
 [x] Throws an exception when an invalid template is set
 [x] Throws an exception when an unsafe template is set

s9e\TextFormatter\Tests\Plugins\Emoticons\Parser
 [x] Parsing tests
 [x] Parsing+rendering tests

s9e\TextFormatter\Tests\Plugins\Escaper\Configurator
 [x] Automatically creates an "ESC" tag
 [x] The name of the tag used can be changed through the "tagName" constructor option
 [x] Has a quickMatch
 [x] Generates a regexp for its config array
 [x] The config array contains the name of the tag

s9e\TextFormatter\Tests\Plugins\Escaper\Parser
 [x] Parsing tests
 [x] Parsing+rendering tests

s9e\TextFormatter\Tests\Plugins\Generic\Configurator
 [x] add() returns the name of the tag it creates
 [x] add() throws an exception if the regexp is invalid
 [x] add() throws an exception on duplicate named subpatterns
 [x] add() creates a tag to represent the replacement
 [x] add() creates an attribute for each named subpattern
 [x] add() creates a regexp filter for each attribute created
 [x] An error occuring during add() does not leave a half-configured tag in the configurator's collection
 [x] asConfig() returns FALSE if no replacements were set
 [x] asConfig() returns the regexps in a "regexps" array where keys are tag names

s9e\TextFormatter\Tests\Plugins\Generic\Parser
 [x] Parsing tests
 [x] Parsing+rendering tests

s9e\TextFormatter\Tests\Plugins\HTMLElements\Configurator
 [x] allowElement('b') creates a tag named 'html:b'
 [x] allowElement('B') creates a tag named 'html:b'
 [x] The prefix can be customized at loading time through the 'prefix' property
 [x] allowElement('script') throws an exception
 [x] allowUnsafeElement('script') allows the 'script' element
 [x] allowAttribute('b', 'title') creates an attribute 'title' on tag 'html:b'
 [x] Attributes created by allowAttribute() are considered optional
 [x] Attributes that are known to expect an URL are created with the '#url' filter
 [x] allowAttribute('b', 'title') throws an exception if 'b' was not explicitly allowed
 [x] allowAttribute('span', 'onmouseover') throws an exception
 [x] allowAttribute('span', 'style') throws an exception
 [x] allowAttribute('span', 'onmouseover') allows the 'onmouseover' attribute on 'span' elements
 [x] allowElement('*invalid*') throws an exception
 [x] allowAttribute('b', '*invalid*') throws an exception
 [x] asConfig() returns FALSE if no elements were allowed
 [x] Has a quickMatch
 [x] Generates a regexp for its config array

s9e\TextFormatter\Tests\Plugins\HTMLElements\Parser
 [x] Parsing tests
 [x] Parsing+rendering tests

s9e\TextFormatter\Tests\Plugins\HTMLEntities\Configurator
 [x] Automatically creates an "HE" tag
 [x] The name of the tag used can be changed through the "tagName" constructor option
 [x] The name of the attribute used can be changed through the "attrName" constructor option
 [x] disable() throws an exception on invalid entity
 [x] Has a quickMatch
 [x] Generates a regexp for its config array
 [x] The config array contains the name of the tag
 [x] The config array contains the name of the attribute
 [x] The config array contains the disabled entities, if any

s9e\TextFormatter\Tests\Plugins\HTMLEntities\Parser
 [x] Parsing tests
 [x] Parsing+rendering tests

s9e\TextFormatter\Tests\Plugins\WittyPants\Configurator
 [x] Automatically creates a "WP" tag
 [x] Does not attempt to create a tag if it already exists
 [x] The name of the tag used can be changed through the "tagName" constructor option
 [x] The name of the attribute used can be changed through the "attrName" constructor option
 [x] The config array contains the name of the tag
 [x] The config array contains the name of the attribute

s9e\TextFormatter\Tests\Plugins\WittyPants\Parser
 [x] Parsing tests
 [x] Parsing+rendering tests

s9e\TextFormatter\Tests\Renderer
 [x] Renders plain text
 [x] Renders multi-line text
 [x] Renders rich text
 [x] renderMulti() renders multiple messages at once
 [x] renderMulti() preserves keys and order
 [x] Renderer is serializable

s9e\TextFormatter\Tests\Unparser
 [x] unparse('<pt>Plain text</pt>') returns 'Plain text'
 [x] asPlainText('<pt>Plain text</pt>') returns 'Plain text'
 [x] unparse('<pt>&lt;Plain text&gt;</pt>') returns '<Plain text>'
 [x] asPlainText('<pt>&lt;Plain text&gt;</pt>') returns '<Plain text>'
 [x] unparse("<mt>a<br />\nb</mt>") returns "a\nb"
 [x] asPlainText("<mt>a<br />\nb</mt>") returns "a\nb"
 [x] unparse('<rt><B><st>[b]</st>Rich<et>[/b]</et></B> text <E>:)</E></rt>') returns '[b]Rich[/b] text :)'
 [x] asPlainText('<rt><B><st>[b]</st>Rich<et>[/b]</et></B> text <E>:)</E></rt>') returns 'Rich text :)'

